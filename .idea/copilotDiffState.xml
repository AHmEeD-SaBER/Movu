<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/authentication/data/src/main/java/com/movu/authentication/data/examples/AuthenticationUsageExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/authentication/data/src/main/java/com/movu/authentication/data/examples/AuthenticationUsageExample.kt" />
              <option name="updatedContent" value="package com.movu.authentication.data.examples&#10;&#10;import com.movu.authentication.data.models.AuthResult&#10;import com.movu.authentication.data.models.SignInRequest&#10;import com.movu.authentication.data.models.SignUpRequest&#10;import com.movu.authentication.data.repositories.IAuthRepository&#10;import com.movu.authentication.data.utils.AuthUtils&#10;import kotlinx.coroutines.flow.collect&#10;import kotlinx.coroutines.launch&#10;import org.koin.core.component.KoinComponent&#10;import org.koin.core.component.inject&#10;&#10;/**&#10; * Example usage of the Authentication Data Layer with proper Koin DI&#10; */&#10;class AuthenticationUsageExample : KoinComponent {&#10;    &#10;    // Proper Koin dependency injection using 'by inject()'&#10;    private val authRepository: IAuthRepository by inject()&#10;    &#10;    /**&#10;     * Example: Complete Sign Up Flow with Firebase Auth + Firestore&#10;     */&#10;    suspend fun signUpExample() {&#10;        // ...existing code...&#10;    }&#10;    &#10;    /**&#10;     * Example: Complete Sign In Flow  &#10;     */&#10;    suspend fun signInExample() {&#10;        // ...existing code...&#10;    }&#10;    &#10;    // ...rest of existing code...&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/authentication/data/src/main/java/com/movu/authentication/data/repositories/AuthRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/authentication/data/src/main/java/com/movu/authentication/data/repositories/AuthRepositoryImpl.kt" />
              <option name="originalContent" value="package com.movu.authentication.data.repositories&#10;&#10;import com.movu.authentication.data.data_sources.IAuthDataSource&#10;import com.movu.authentication.data.models.AuthResult&#10;import com.movu.authentication.data.models.SignInRequest&#10;import com.movu.authentication.data.models.SignUpRequest&#10;import com.movu.authentication.data.models.UserDto&#10;import com.movu.authentication.data.models.UserProfile&#10;import com.movu.userpreferences.domain.UserAuthManager&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;class AuthRepositoryImpl(&#10;    private val authDataSource: IAuthDataSource,&#10;    private val userAuthManager: UserAuthManager&#10;) : IAuthRepository {&#10;&#10;    // ...existing code...&#10;" />
              <option name="updatedContent" value="package com.movu.authentication.data.repositories&#10;&#10;import com.movu.authentication.data.data_sources.IAuthDataSource&#10;import com.movu.authentication.data.models.AuthResult&#10;import com.movu.authentication.data.models.SignInRequest&#10;import com.movu.authentication.data.models.SignUpRequest&#10;import com.movu.authentication.data.models.UserDto&#10;import com.movu.authentication.data.models.UserProfile&#10;import com.movu.userpreferences.domain.UserAuthManager&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;class AuthRepositoryImpl(&#10;    private val authDataSource: IAuthDataSource,&#10;    private val userAuthManager: UserAuthManager&#10;) : IAuthRepository {&#10;&#10;    override suspend fun signUp(request: SignUpRequest): AuthResult&lt;UserProfile&gt; {&#10;        // First check if username is available&#10;        return when (val usernameCheck = authDataSource.checkUsernameAvailability(request.username)) {&#10;            is AuthResult.Success -&gt; {&#10;                if (usernameCheck.data) {&#10;                    // Username is available, proceed with signup&#10;                    when (val signUpResult = authDataSource.signUp(request)) {&#10;                        is AuthResult.Success -&gt; {&#10;                            val firebaseUser = signUpResult.data&#10;                            val userProfile = UserProfile(&#10;                                uid = firebaseUser.uid,&#10;                                email = firebaseUser.email ?: request.email,&#10;                                username = request.username,&#10;                                displayName = request.displayName ?: request.username,&#10;                                profileImageUrl = null,&#10;                                isEmailVerified = firebaseUser.isEmailVerified&#10;                            )&#10;                            &#10;                            // Save auth state to SharedPreferences&#10;                            userAuthManager.onSignInLoginComplete(firebaseUser)&#10;                            &#10;                            AuthResult.Success(userProfile)&#10;                        }&#10;                        is AuthResult.Error -&gt; AuthResult.Error(signUpResult.exception)&#10;                        else -&gt; AuthResult.Error(Exception(&quot;Unknown error during signup&quot;))&#10;                    }&#10;                } else {&#10;                    AuthResult.Error(Exception(&quot;Username is already taken&quot;))&#10;                }&#10;            }&#10;            is AuthResult.Error -&gt; usernameCheck&#10;            else -&gt; AuthResult.Error(Exception(&quot;Failed to check username availability&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun signIn(request: SignInRequest): AuthResult&lt;UserProfile&gt; {&#10;        return when (val signInResult = authDataSource.signIn(request)) {&#10;            is AuthResult.Success -&gt; {&#10;                val firebaseUser = signInResult.data&#10;                &#10;                // Get user data from Firestore&#10;                when (val userDataResult = authDataSource.getUserFromFirestore(firebaseUser.uid)) {&#10;                    is AuthResult.Success -&gt; {&#10;                        val userDto = userDataResult.data&#10;                        val userProfile = userDto.toUserProfile()&#10;                        &#10;                        // Save auth state to SharedPreferences&#10;                        userAuthManager.onSignInLoginComplete(firebaseUser)&#10;                        &#10;                        AuthResult.Success(userProfile)&#10;                    }&#10;                    is AuthResult.Error -&gt; AuthResult.Error(userDataResult.exception)&#10;                    else -&gt; AuthResult.Error(Exception(&quot;Failed to retrieve user data&quot;))&#10;                }&#10;            }&#10;            is AuthResult.Error -&gt; AuthResult.Error(signInResult.exception)&#10;            else -&gt; AuthResult.Error(Exception(&quot;Unknown error during sign in&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun signOut(): AuthResult&lt;Unit&gt; {&#10;        return when (val signOutResult = authDataSource.signOut()) {&#10;            is AuthResult.Success -&gt; {&#10;                // Clear SharedPreferences&#10;                userAuthManager.clearAuthData()&#10;                AuthResult.Success(Unit)&#10;            }&#10;            is AuthResult.Error -&gt; AuthResult.Error(signOutResult.exception)&#10;            else -&gt; AuthResult.Error(Exception(&quot;Unknown error during sign out&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun getCurrentUserProfile(): AuthResult&lt;UserProfile&gt; {&#10;        val currentUser = authDataSource.getCurrentUser()&#10;        return if (currentUser != null) {&#10;            when (val userDataResult = authDataSource.getUserFromFirestore(currentUser.uid)) {&#10;                is AuthResult.Success -&gt; {&#10;                    val userProfile = userDataResult.data.toUserProfile()&#10;                    AuthResult.Success(userProfile)&#10;                }&#10;                is AuthResult.Error -&gt; AuthResult.Error(userDataResult.exception)&#10;                else -&gt; AuthResult.Error(Exception(&quot;Failed to retrieve user data&quot;))&#10;            }&#10;        } else {&#10;            AuthResult.Error(Exception(&quot;No user is currently signed in&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun isUserLoggedIn(): Boolean {&#10;        return authDataSource.getCurrentUser() != null &amp;&amp; userAuthManager.isUserAuthenticated()&#10;    }&#10;&#10;    override suspend fun sendEmailVerification(): AuthResult&lt;Unit&gt; {&#10;        return authDataSource.sendEmailVerification()&#10;    }&#10;&#10;    override suspend fun resetPassword(email: String): AuthResult&lt;Unit&gt; {&#10;        return authDataSource.resetPassword(email)&#10;    }&#10;&#10;    override suspend fun updateUserProfile(updates: Map&lt;String, Any&gt;): AuthResult&lt;Unit&gt; {&#10;        val currentUser = authDataSource.getCurrentUser()&#10;        return if (currentUser != null) {&#10;            authDataSource.updateUserInFirestore(currentUser.uid, updates)&#10;        } else {&#10;            AuthResult.Error(Exception(&quot;No user is currently signed in&quot;))&#10;        }&#10;    }&#10;&#10;    override suspend fun checkUsernameAvailability(username: String): AuthResult&lt;Boolean&gt; {&#10;        return authDataSource.checkUsernameAvailability(username)&#10;    }&#10;&#10;    override suspend fun deleteAccount(): AuthResult&lt;Unit&gt; {&#10;        val currentUser = authDataSource.getCurrentUser()&#10;        return if (currentUser != null) {&#10;            // First delete user data from Firestore&#10;            when (val deleteResult = authDataSource.deleteUserFromFirestore(currentUser.uid)) {&#10;                is AuthResult.Success -&gt; {&#10;                    // Then delete Firebase Auth user&#10;                    try {&#10;                        currentUser.delete()&#10;                        userAuthManager.clearAuthData()&#10;                        AuthResult.Success(Unit)&#10;                    } catch (e: Exception) {&#10;                        AuthResult.Error(e)&#10;                    }&#10;                }&#10;                is AuthResult.Error -&gt; AuthResult.Error(deleteResult.exception)&#10;                else -&gt; AuthResult.Error(Exception(&quot;Failed to delete user data&quot;))&#10;            }&#10;        } else {&#10;            AuthResult.Error(Exception(&quot;No user is currently signed in&quot;))&#10;        }&#10;    }&#10;&#10;    override fun observeCurrentUserProfile(): Flow&lt;AuthResult&lt;UserProfile&gt;&gt; {&#10;        val currentUser = authDataSource.getCurrentUser()&#10;        return if (currentUser != null) {&#10;            authDataSource.observeUserData(currentUser.uid).map { result -&gt;&#10;                when (result) {&#10;                    is AuthResult.Success -&gt; AuthResult.Success(result.data.toUserProfile())&#10;                    is AuthResult.Error -&gt; AuthResult.Error(result.exception)&#10;                    else -&gt; AuthResult.Error(Exception(&quot;Unknown error observing user data&quot;))&#10;                }&#10;            }&#10;        } else {&#10;            kotlinx.coroutines.flow.flow {&#10;                emit(AuthResult.Error(Exception(&quot;No user is currently signed in&quot;)))&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun completeAuthentication(userProfile: UserProfile): AuthResult&lt;Unit&gt; {&#10;        return try {&#10;            val currentUser = authDataSource.getCurrentUser()&#10;            if (currentUser != null) {&#10;                userAuthManager.onSignInLoginComplete(currentUser)&#10;                AuthResult.Success(Unit)&#10;            } else {&#10;                AuthResult.Error(Exception(&quot;No Firebase user found&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            AuthResult.Error(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun clearAuthenticationState(): AuthResult&lt;Unit&gt; {&#10;        return try {&#10;            userAuthManager.clearAuthData()&#10;            AuthResult.Success(Unit)&#10;        } catch (e: Exception) {&#10;            AuthResult.Error(e)&#10;        }&#10;    }&#10;&#10;    // Extension function to convert UserDto to UserProfile&#10;    private fun UserDto.toUserProfile(): UserProfile {&#10;        return UserProfile(&#10;            uid = this.uid,&#10;            email = this.email,&#10;            username = this.username,&#10;            displayName = this.displayName,&#10;            profileImageUrl = this.profileImageUrl,&#10;            isEmailVerified = this.isEmailVerified&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/details/domain/src/main/java/com/example/domain/usecases/watchlist/IWatchlistUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/details/domain/src/main/java/com/example/domain/usecases/watchlist/IWatchlistUseCase.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="// This file should be deleted - watchlist functionality belongs in repository layer" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/details/domain/src/main/java/com/example/domain/usecases/watchlist/WatchlistUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/details/domain/src/main/java/com/example/domain/usecases/watchlist/WatchlistUseCase.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="// This file should be deleted - watchlist functionality belongs in repository layer" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>